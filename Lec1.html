<!DOCTYPE html>
<html lang="es" class"no-js">
    <head>
 		<meta charset="UTF-8">
        <meta content="Luis Roncancio" name="author"/>
        <meta content="Pagina de curso de Disenos de Sitios Web" name="description" />
        <meta content="EDUCACION, UNAD, INGENIERIA, SISTEMAS, DISENO, OVA, CURSO, WEB" name="keywords" />
        <link href="favicon.ico" rel="shortcut icon" type="image/x-icon" />
        <title>OVA INTRODUCCIÓN DESARROLLO SOFTWARE</title>
        <link rel="stylesheet" href="css/normalize.css">
        <link href='http://fonts.googleapis.com/css?family=arial' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="css/style.css">
     </head>
    <body>	
        <Div id="contenidos">
            <header>
                <div id="apDiv1"><img src="img/banner.jpg" width="1000" height="168">
                  <div id="apDiv24">OVA Para curso Introducción al Desarrollo de Software</div>
              </div>
            </header>
        	<p>&nbsp;</p>
   			<p>&nbsp;</p>
            <p>&nbsp;</p>
    		<nav>
              <ul class="menu">
                                <li><a href="index.html" class="menu">Inicio</a></li>
                <li><a>Lecturas</a>
                  <ul>
					<li><a href="Lec1.html" class="menu">Definición e Historia</a></li>
					<li><a href="Lec2.html" class="menu">Ciclos y Procesos del Software</a></li>
					<li><a href="Lec3.html" class="menu">Calidad y Clasificación del Software</a></li>
                   </ul>
				</li>
                <li><a href="Multimedia.html" class="menu">Multimedia</a></li>
                <li class="parent"><a class="menu">Actividades</a>                
               	  <ul>
                   	<li><a href="Acti1.html" class="menu">Actividades ludicas</a></li>
                    <li><a href="Acti2.html" class="menu">Actividades de refuerzo</a></li>
                  </ul>
                </li>
                <li><a href="Autores.html" class="menu">Autores</a></li>
                </ul>
                <div id="apDiv19">
                <center>
                	<div id="cuentavisitas"></div>
						<script>yu=function(id){return document.getElementById(id);}
							if(localStorage){
							if(localStorage['visitas']==undefined){
							localStorage['visitas']=0;
							}var n=parseInt(localStorage['visitas']);localStorage['visitas']=1+n;
							var num=localStorage['visitas'];
							var mensaje=num + " visitas";
							 yu('cuentavisitas').innerHTML=mensaje;}
                        </script>
                </center></div>
      <div id="apDiv4"><a id="l1" target="_blank" rel="nofollow" href="https://www.facebook.com/Universidad-Nacional-Abierta-y-a-Distancia-UNAD-285790428108305/"><img title="Facebook"border="0" src="img/facebook_aqu_32.png" alt="Facebook" /></a><a href="https://www.youtube.com/user/universidadunad" target="_blank"><img src="img/youtube.png" alt="YouTube" title="Youtube" border="0" /></a><a href="https://twitter.com/UniversidadUNAD" target="_blank"><img src="img/twitter_aqu_32.png" class="menu" title="Twitter" border="0" /></a></span></div> 
              </ul>
                 <div id="apDiv3">    
               	   <form method="get" action="http://www.google.es/search">
                    <input type="hidden" name="ie" value="UTF-8" />
                    <input type="hidden" name="oe" value="UTF-8" />
                    <input type="text" id="s" name="q" value="" size="12" />
                    <font size=-1>
                    <input type="submit"  id="x" name="btnG" value="Buscar" />
                    <input type="hidden" name="domains" value="https://estudios.unad.edu.co/ingenieria-de-sistemas" />
                    <br />
                    <input type="radio" name="sitesearch" value="" />
                    <font color="white"> Internet</font>
                    <input type="radio" name="sitesearch" value="https://estudios.unad.edu.co/ingenieria-de-sistemas" checked="checked" />
                    <font color="white"> ECBTI </font>
                   </form>
                </div>
             </nav>
            <div id="apDiv14"><a href="https://campus0a.unad.edu.co/campus0/login/index.php" target="_blank"><img src="img/campus.png" width="116" height="101"></a>									</div>
    <section>
    <h2>Diseño de Sitios Web - UNAD ECBTI</h2>
    
    <div id="apDiv20"><a href="https://informacion.unad.edu.co/correo" target="_blank"><img src="img/rss_aqu_32.png" class="menu" title="Correo Institucional" border="0" /></a></div>
                <article>
                  <p><br>
                  <h1 id="firstHeading" lang="es">Software</h1>
                  <p>Se conoce como <em><strong>software</strong></em><a href="https://es.wikipedia.org/wiki/Software#cite_note-1">1</a> <em>al equipo lógico o <a href="https://es.wikipedia.org/wiki/Sistema_l%C3%B3gico" title="Sistema lógico">soporte lógico</a></em> de un <a href="https://es.wikipedia.org/wiki/Sistema_inform%C3%A1tico" title="Sistema informático">sistema informático</a>, que comprende el conjunto de los componentes <strong>lógicos</strong> necesarios que hacen posible la realización de tareas específicas, en contraposición a los componentes<strong>físicos</strong> que son llamados <a href="https://es.wikipedia.org/wiki/Hardware" title="Hardware">hardware</a>.</p>
                  <p>Los componentes lógicos incluyen, entre otros muchos, las <a href="https://es.wikipedia.org/wiki/Aplicaci%C3%B3n_inform%C3%A1tica" title="Aplicación informática">aplicaciones informáticas</a>, tales como el <a href="https://es.wikipedia.org/wiki/Procesador_de_texto" title="Procesador de texto">procesador de texto</a>, que permite al usuario realizar todas las tareas concernientes a la edición de textos; el llamado <a href="https://es.wikipedia.org/wiki/Software_de_sistema" title="Software de sistema">software de sistema</a>, tal como el<a href="https://es.wikipedia.org/wiki/Sistema_operativo" title="Sistema operativo">sistema operativo</a>, que básicamente permite al resto de los programas funcionar adecuadamente, facilitando también la interacción entre los componentes físicos y el resto de las aplicaciones, y proporcionando una <a href="https://es.wikipedia.org/wiki/Interfaz_de_usuario" title="Interfaz de usuario">interfaz</a> con el usuario.</p>
                  <p>El <a href="https://es.wikipedia.org/wiki/Anglicismo" title="Anglicismo">anglicismo</a> <em>software</em> es el más ampliamente difundido al referirse a este concepto, especialmente en la <a href="https://es.wikipedia.org/wiki/Terminolog%C3%ADa_t%C3%A9cnica" title="Terminología técnica">jerga técnica</a>; en tanto que el término sinónimo «logicial», derivado del término francés <em>logiciel</em>, es utilizado mayormente en países y zonas de influencia francesa. Su abreviatura es <strong>Sw</strong>.</p>
                  <h2><span id="Definici.C3.B3n_de_software">Definición de software</span></h2>
                  <p>Existen varias definiciones similares aceptadas para software, pero probablemente la más formal sea la siguiente:</p>
                  <blockquote>
                    <p>Es el conjunto de los programas de cómputo, procedimientos, reglas, documentación y datos asociados, que forman parte de las operaciones de un sistema de computación.</p>
                    <div>Extraído del estándar 729 del <a href="https://es.wikipedia.org/wiki/IEEE" title="IEEE">IEEE</a><a href="https://es.wikipedia.org/wiki/Software#cite_note-5">5</a></div>
                  </blockquote>
                  <p>Considerando esta definición, el concepto de software va más allá de los programas de computación en sus distintos estados: <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_fuente" title="Código fuente">código fuente</a>, <a href="https://es.wikipedia.org/wiki/Archivo_binario" title="Archivo binario">binario</a> o <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_ejecutable" title="Código ejecutable">ejecutable</a>; también su documentación, los datos a procesar e incluso la información de usuario forman parte del software: es decir, <em>abarca todo lo intangible</em>, todo lo «no físico» relacionado.</p>
                  <p>El término «software» fue usado por primera vez en este sentido por <a href="https://es.wikipedia.org/wiki/John_W._Tukey" title="John W. Tukey">John W. Tukey</a> en <a href="https://es.wikipedia.org/wiki/1957" title="1957">1957</a>. En la ingeniería de software y las <a href="https://es.wikipedia.org/wiki/Ciencias_de_la_computaci%C3%B3n" title="Ciencias de la computación">ciencias de la computación</a>, el software es toda la <a href="https://es.wikipedia.org/wiki/Informaci%C3%B3n" title="Información">información</a> procesada por los <a href="https://es.wikipedia.org/wiki/Sistema_inform%C3%A1tico" title="Sistema informático">sistemas informáticos</a>: programas y <a href="https://es.wikipedia.org/wiki/Dato" title="Dato">datos</a>.</p>
                  <p><em>El concepto</em> de leer diferentes secuencias de instrucciones (<a href="https://es.wikipedia.org/wiki/Programa_inform%C3%A1tico" title="Programa informático">programa</a>) desde la <a href="https://es.wikipedia.org/wiki/Memoria_de_computadora" title="Memoria de computadora">memoria</a> de un dispositivo para controlar los cálculos fue introducido por <a href="https://es.wikipedia.org/wiki/Charles_Babbage" title="Charles Babbage">Charles Babbage</a> como parte de su <a href="https://es.wikipedia.org/wiki/M%C3%A1quina_diferencial" title="Máquina diferencial">máquina diferencial</a>. <em>La teoría</em> que forma la base de la mayor parte del software moderno fue propuesta por <a href="https://es.wikipedia.org/wiki/Alan_Turing" title="Alan Turing">Alan Turing</a> en su ensayo de 1936, «Los números computables», con una aplicación al problema de decisión.</p>
                  <p>&nbsp;</p>
                  <h2><span id="Clasificaci.C3.B3n_del_software">Clasificación del software</span></h2>
                  <p>Si bien esta distinción es, en cierto modo, arbitraria, y a veces confusa, a los fines prácticos se puede clasificar al software en tres tipos:</p>
                  <ul>
                    <li><strong><a href="https://es.wikipedia.org/wiki/Software_de_sistema" title="Software de sistema">Software de sistema</a>:</strong> Su objetivo es desvincular adecuadamente al usuario y al programador de los detalles del sistema informático en particular que se use, aislándolo especialmente del procesamiento referido a las características internas de: memoria, discos, puertos y dispositivos de comunicaciones, impresoras, pantallas, teclados, etc. El software de sistema le procura al usuario y programador adecuadas <a href="https://es.wikipedia.org/wiki/Interfaz_de_usuario" title="Interfaz de usuario">interfaces de alto nivel</a>, <a href="https://es.wikipedia.org/wiki/Controlador_de_dispositivo" title="Controlador de dispositivo">controladores</a>, herramientas y utilidades de apoyo que permiten el<a href="https://es.wikipedia.org/wiki/Mantenimiento" title="Mantenimiento">mantenimiento</a> del sistema global. Incluye entre otros:
                      <ul>
                        <li><a href="https://es.wikipedia.org/wiki/Sistema_operativo" title="Sistema operativo">Sistemas operativos</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Controlador_de_dispositivo" title="Controlador de dispositivo">Controladores de dispositivos</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Herramienta_de_diagn%C3%B3stico" title="Herramienta de diagnóstico">Herramientas de diagnóstico</a></li>
                        <li><a href="https://es.wikipedia.org/w/index.php?title=Herramienta_de_Correcci%C3%B3n_y_Optimizaci%C3%B3n&action=edit&redlink=1" title="Herramienta de Corrección y Optimización (aún no redactado)">Herramientas de Corrección y Optimización</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Servidor_inform%C3%A1tico" title="Servidor informático">Servidores</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Utilidad_(inform%C3%A1tica)" title="Utilidad (informática)">Utilidades</a></li>
                      </ul>
                    </li>
                    <li><strong><a href="https://es.wikipedia.org/wiki/Software_de_programaci%C3%B3n" title="Software de programación">Software de programación</a>:</strong> Es el conjunto de herramientas que permiten al <a href="https://es.wikipedia.org/wiki/Programador" title="Programador">programador</a> desarrollar programas de informática, usando diferentes alternativas y <a href="https://es.wikipedia.org/wiki/Lenguaje_de_programaci%C3%B3n" title="Lenguaje de programación">lenguajes de programación</a>, de una manera práctica. Incluyen en forma básica:
                      <ul>
                        <li><a href="https://es.wikipedia.org/wiki/Editor_de_texto" title="Editor de texto">Editores de texto</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Compilador" title="Compilador">Compiladores</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Int%C3%A9rprete_inform%C3%A1tico" title="Intérprete informático">Intérpretes</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Enlazador" title="Enlazador">Enlazadores</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Depurador" title="Depurador">Depuradores</a></li>
                        <li>Entornos de Desarrollo Integrados (<a href="https://es.wikipedia.org/wiki/Entorno_de_desarrollo_integrado" title="Entorno de desarrollo integrado">IDE</a>): Agrupan las anteriores herramientas, usualmente en un entorno visual, de forma tal que el programador no necesite introducir múltiples <a href="https://es.wikipedia.org/wiki/Comando_(inform%C3%A1tica)" title="Comando (informática)">comandos</a> para compilar, interpretar, <a href="https://es.wikipedia.org/wiki/Depuraci%C3%B3n_de_programas" title="Depuración de programas">depurar</a>, etc. Habitualmente cuentan con una avanzada <a href="https://es.wikipedia.org/wiki/Interfaz_gr%C3%A1fica_de_usuario" title="Interfaz gráfica de usuario">interfaz gráfica de usuario</a> (<a href="https://es.wikipedia.org/wiki/GUI" title="GUI">GUI</a>).</li>
                      </ul>
                    </li>
                    <li><strong><a href="https://es.wikipedia.org/wiki/Software_de_aplicaci%C3%B3n" title="Software de aplicación">Software de aplicación</a></strong>: Es aquel que permite a los usuarios llevar a cabo una o varias tareas específicas, en cualquier campo de actividad susceptible de ser automatizado o asistido, con especial énfasis en los negocios. Incluye entre muchos otros:
                      <ul>
                        <li>Aplicaciones para <a href="https://es.wikipedia.org/wiki/Sistema_de_control" title="Sistema de control">Control de sistemas</a> y <a href="https://es.wikipedia.org/wiki/Automatizaci%C3%B3n" title="Automatización">automatización</a> <a href="https://es.wikipedia.org/wiki/Industria" title="Industria">industrial</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Aplicaci%C3%B3n_ofim%C3%A1tica" title="Aplicación ofimática">Aplicaciones ofimáticas</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Software_educativo" title="Software educativo">Software educativo</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Software_empresarial" title="Software empresarial">Software empresarial</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Bases_de_datos" title="Bases de datos">Bases de datos</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Telecomunicaciones" title="Telecomunicaciones">Telecomunicaciones</a> (por ejemplo Internet y toda su estructura lógica)</li>
                        <li><a href="https://es.wikipedia.org/wiki/Videojuegos" title="Videojuegos">Videojuegos</a></li>
                        <li><a href="https://es.wikipedia.org/wiki/Software_m%C3%A9dico" title="Software médico">Software médico</a></li>
                        <li>Software de <a href="https://es.wikipedia.org/wiki/C%C3%A1lculo_num%C3%A9rico" title="Cálculo numérico">cálculo numérico</a> y simbólico.</li>
                        <li>Software de diseño asistido (<a href="https://es.wikipedia.org/wiki/Dise%C3%B1o_asistido_por_computadora" title="Diseño asistido por computadora">CAD</a>)</li>
                        <li>Software de control numérico (<a href="https://es.wikipedia.org/wiki/Fabricaci%C3%B3n_asistida_por_computadora" title="Fabricación asistida por computadora">CAM</a>)</li>
                      </ul>
                    </li>
                  </ul>
                  <h2><span id="Proceso_de_creaci.C3.B3n_del_software">Proceso de creación del software</span></h2>
                  <div>Artículo principal: <em><a href="https://es.wikipedia.org/wiki/Proceso_para_el_desarrollo_de_software" title="Proceso para el desarrollo de software">Proceso para el desarrollo de software</a></em></div>
                  <p>Se define como <em>proceso</em> al conjunto ordenado de pasos a seguir para llegar a la solución de un problema u obtención de un producto, en este caso particular, para lograr un producto software que resuelva un problema específico.</p>
                  <p>El proceso de creación de software puede llegar a ser muy complejo, dependiendo de su porte, características y criticidad del mismo. Por ejemplo la creación de un sistema operativo es una tarea que requiere proyecto, gestión, numerosos recursos y todo un equipo disciplinado de trabajo. En el otro extremo, si se trata de un sencillo programa (por ejemplo, la resolución de una ecuación de segundo orden), éste puede ser realizado por un solo programador (incluso aficionado) fácilmente. Es así que normalmente se dividen en tres categorías según su tamaño (<a href="https://es.wikipedia.org/wiki/L%C3%ADneas_de_c%C3%B3digo" title="Líneas de código">líneas de código</a>) o costo: de <em>«pequeño»</em>, <em>«mediano»</em> y <em>«gran porte»</em>. Existen varias metodologías para <strong>estimarlo</strong>, una de las más populares es el sistema <a href="https://es.wikipedia.org/wiki/COCOMO" title="COCOMO">COCOMO</a> que provee métodos y un software (programa) que calcula y provee una aproximación de todos los costos de producción en un «proyecto software» (relación horas/hombre, costo monetario, cantidad de líneas fuente de acuerdo a lenguaje usado, etc.).</p>
                  <p>Considerando los de gran porte, es necesario realizar complejas tareas, tanto técnicas como de gerencia, una fuerte gestión y análisis diversos (entre otras cosas), la complejidad de ello ha llevado a que desarrolle una ingeniería específica para tratar su estudio y realización: es conocida como <a href="https://es.wikipedia.org/wiki/Ingenier%C3%ADa_de_Software" title="Ingeniería de Software">Ingeniería de Software</a>.</p>
                  <p>En tanto que en los de mediano porte, pequeños equipos de trabajo (incluso un avezado <a href="https://es.wikipedia.org/wiki/Programador" title="Programador">analista-programador</a> solitario) pueden realizar la tarea. Aunque, siempre en casos de mediano y gran porte (y a veces también en algunos de pequeño porte, según su complejidad), se deben seguir ciertas etapas que son necesarias para la construcción del software. Tales etapas, si bien deben existir, son flexibles en su forma de aplicación, de acuerdo a la metodología o <a href="https://es.wikipedia.org/wiki/Proceso_para_el_desarrollo_de_software" title="Proceso para el desarrollo de software">proceso de desarrollo</a> escogido y utilizado por el equipo de desarrollo o por el analista-programador solitario (si fuere el caso).</p>
                  <p>Los «<strong>procesos de desarrollo de software</strong>» poseen reglas preestablecidas, y deben ser aplicados en la creación del software de mediano y gran porte, ya que en caso contrario lo más seguro es que el proyecto no logre concluir o termine sin cumplir los objetivos previstos, y con variedad de fallos inaceptables (fracasan, en pocas palabras). Entre tales «procesos» los hay ágiles o livianos (ejemplo <a href="https://es.wikipedia.org/wiki/Programaci%C3%B3n_Extrema" title="Programación Extrema">XP</a>), pesados y lentos (ejemplo <a href="https://es.wikipedia.org/wiki/RUP" title="RUP">RUP</a>), y variantes intermedias. Normalmente se aplican de acuerdo al tipo y porte del software a desarrollar, a criterio del líder (si lo hay) del equipo de desarrollo. Algunos de esos procesos son <a href="https://es.wikipedia.org/wiki/Programaci%C3%B3n_Extrema" title="Programación Extrema">Programación Extrema</a> (en inglés <em>eXtreme Programming</em> o XP),<a href="https://es.wikipedia.org/wiki/Proceso_Unificado_de_Rational" title="Proceso Unificado de Rational">Proceso Unificado de Rational</a> (en inglés Rational Unified Process o RUP), Feature Driven Development (<a href="https://es.wikipedia.org/w/index.php?title=Feature_Driven_Development&action=edit&redlink=1" title="Feature Driven Development (aún no redactado)">FDD</a>), etc.</p>
                  <p>Cualquiera sea el «proceso» utilizado y aplicado al desarrollo del software (RUP, FDD, XP, etc), y casi independientemente de él, siempre se debe aplicar un «modelo de ciclo de vida».<a href="https://es.wikipedia.org/wiki/Software#cite_note-Cvida-6">6</a></p>
                  <p>Se estima que, del total de proyectos software grandes emprendidos, un 28 % fracasan, un 46 % caen en severas modificaciones que lo retrasan y un 26 % son totalmente exitosos.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Pressman-Proceso-7">7</a></p>
                  <p>Cuando un proyecto fracasa, rara vez es debido a fallas técnicas, la principal causa de fallos y fracasos es la falta de aplicación de una buena metodología o proceso de desarrollo. Entre otras, una fuerte tendencia, desde hace pocas décadas, es mejorar las metodologías o procesos de desarrollo, o crear nuevas y concientizar a los profesionales de la <a href="https://es.wikipedia.org/wiki/Inform%C3%A1tica" title="Informática">informática</a> a su utilización adecuada. Normalmente los especialistas en el estudio y desarrollo de estas áreas (metodologías) y afines (tales como modelos y hasta la gestión misma de los proyectos) son los ingenieros en software, es su orientación. Los especialistas en cualquier otra área de desarrollo informático (analista, programador, Lic. en informática, ingeniero en informática, ingeniero de sistemas, etc.) normalmente aplican sus conocimientos especializados pero utilizando modelos, paradigmas y procesos ya elaborados.</p>
                  <p>Es común para el desarrollo de software de mediano porte que los equipos humanos involucrados apliquen «metodologías propias», normalmente un híbrido de los procesos anteriores y a veces con criterios propios.</p>
                  <p>El proceso de desarrollo puede involucrar numerosas y variadas tareas,<a href="https://es.wikipedia.org/wiki/Software#cite_note-Cvida-6">6</a> desde lo administrativo, pasando por lo técnico y hasta la gestión y el gerenciamiento. Pero, casi rigurosamente, siempre se cumplen ciertas <strong>etapas mínimas</strong>; las que se pueden resumir como sigue:</p>
                  <ul>
                    <li>Captura, elicitación<a href="https://es.wikipedia.org/wiki/Software#cite_note-8">8</a> , especificación y análisis de <a href="https://es.wikipedia.org/wiki/Requisito_(sistemas)" title="Requisito (sistemas)">requisitos</a> (ERS)</li>
                    <li>Diseño</li>
                    <li><a href="https://es.wikipedia.org/wiki/Programaci%C3%B3n" title="Programación">Codificación</a></li>
                    <li>Pruebas (unitarias y de integración)</li>
                    <li>Instalación y paso a producción</li>
                    <li><a href="https://es.wikipedia.org/wiki/Mantenimiento_de_software" title="Mantenimiento de software">Mantenimiento</a></li>
                  </ul>
                  <p>En las anteriores etapas pueden variar ligeramente sus nombres, o ser más globales, o contrariamente, ser más refinadas; por ejemplo indicar como una única fase (a los fines documentales e interpretativos) de «análisis y diseño»; o indicar como «implementación» lo que está dicho como «codificación»; pero en rigor, todas existen e incluyen, básicamente, las mismas tareas específicas.</p>
                  <p>En el apartado 4 del presente artículo se brindan mayores detalles de cada una de las etapas indicadas.</p>
                  <h3><span id="Modelos_de_proceso_o_ciclo_de_vida">Modelos de proceso o ciclo de vida</span></h3>
                  <p>Para cada una de las fases o etapas listadas en el ítem anterior, existen sub-etapas (o tareas). El modelo de proceso o modelo de <a href="https://es.wikipedia.org/wiki/Ciclo_de_vida_del_software" title="Ciclo de vida del software">ciclo de vida</a> utilizado para el desarrollo, define el orden de las tareas o actividades involucradas,<a href="https://es.wikipedia.org/wiki/Software#cite_note-Cvida-6">6</a> también define la coordinación entre ellas, y su enlace y realimentación. Entre los más conocidos se puede mencionar:<a href="https://es.wikipedia.org/wiki/Modelo_en_cascada" title="Modelo en cascada">modelo en cascada</a> o secuencial, <a href="https://es.wikipedia.org/wiki/Desarrollo_en_espiral" title="Desarrollo en espiral">modelo espiral</a>, <a href="https://es.wikipedia.org/wiki/Desarrollo_iterativo_y_creciente" title="Desarrollo iterativo y creciente">modelo iterativo incremental</a>. De los antedichos hay a su vez algunas variantes o alternativas, más o menos atractivas según sea la aplicación requerida y sus requisitos.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Pressman-Proceso-7">7</a></p>
                  <h4><span id="Modelo_cascada">Modelo cascada</span></h4>
                  <p>Este, aunque es más comúnmente conocido como <a href="https://es.wikipedia.org/wiki/Modelo_en_cascada" title="Modelo en cascada">modelo en cascada</a> es también llamado «modelo clásico», «modelo tradicional» o «modelo lineal secuencial».</p>
                  <p>El modelo en cascada puro <em>difícilmente se utiliza tal cual</em>, pues esto implicaría un previo y <em>absoluto</em> conocimiento de los requisitos, la no volatilidad de los mismos (o rigidez) y etapas subsiguientes libres de errores; ello sólo podría ser aplicable a escasos y pequeños sistemas a desarrollar. En estas circunstancias, el paso de una etapa a otra de las mencionadas sería sin retorno, por ejemplo pasar del diseño a la codificación implicaría un diseño exacto y sin errores ni probable modificación o evolución: «codifique lo diseñado sin errores, no habrá en absoluto variantes futuras». Esto es utópico; ya que intrínsecamente <em>el software es de carácter evolutivo</em>,<a href="https://es.wikipedia.org/wiki/Software#cite_note-Evo2-9">9</a> cambiante y difícilmente libre de errores, tanto durante su desarrollo como durante su vida operativa.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Cvida-6">6</a></p>
                  <div>
                    <div><a href="https://commons.wikimedia.org/wiki/File:Modelo_Cascada_Secuencial.jpg"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/01/Modelo_Cascada_Secuencial.jpg/350px-Modelo_Cascada_Secuencial.jpg" width="350" height="207" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/0/01/Modelo_Cascada_Secuencial.jpg/525px-Modelo_Cascada_Secuencial.jpg 1.5x, //upload.wikimedia.org/wikipedia/commons/0/01/Modelo_Cascada_Secuencial.jpg 2x" data-file-width="550" data-file-height="325"></a>
                      <div>
                        <div></div>
                        Figura 2: Modelo cascada puro o secuencial para el ciclo de vida del software.</div>
                    </div>
                  </div>
                  <p>Algún cambio durante la ejecución de una cualquiera de las etapas en este modelo secuencial implicaría reiniciar desde el principio todo el ciclo completo, lo cual redundaría en altos costos de tiempo y desarrollo. La Figura 2 muestra un posible esquema de el modelo en cuestión.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Cvida-6">6</a></p>
                  <p>Sin embargo, el modelo cascada en algunas de sus variantes es uno de los actualmente <em>más utilizados</em>,<a href="https://es.wikipedia.org/wiki/Software#cite_note-modelos-10">10</a> por su eficacia y simplicidad, más que nada en software de pequeño y algunos de mediano porte; pero nunca (o muy rara vez) se lo usa en su "forma pura", como se dijo anteriormente. En lugar de ello, siempre se produce alguna<a href="https://es.wikipedia.org/wiki/Realimentaci%C3%B3n" title="Realimentación">realimentación</a> entre etapas, que no es completamente predecible ni rígida; esto da oportunidad al desarrollo de productos software en los cuales hay ciertas incertezas, cambios o evoluciones durante el ciclo de vida. Así por ejemplo, una vez capturados y especificados los requisitos (primera etapa) se puede pasar al diseño del sistema, pero durante esta última fase lo más probable es que se deban realizar ajustes en los requisitos (aunque sean mínimos), ya sea por fallas detectadas, ambigüedades o bien por que los propios requisitos han cambiado o evolucionado; con lo cual se debe retornar a la primera o previa etapa, hacer los reajuste pertinentes y luego continuar nuevamente con el diseño; esto último se conoce como realimentación. <em>Lo normal en el modelo cascada será entonces la aplicación del mismo con sus etapas realimentadas de alguna forma</em>, permitiendo retroceder de una a la anterior (e incluso poder saltar a varias anteriores) si es requerido.</p>
                  <p>De esta manera se obtiene el «modelo cascada realimentado», que puede ser esquematizado.</p>
                  <p>Lo dicho es, a grandes rasgos, la forma y utilización de este modelo, uno de los más usados y populares.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Cvida-6">6</a> El modelo cascada realimentado resulta muy atractivo, hasta ideal, si el proyecto presenta alta rigidez (pocos cambios, previsto no evolutivo), los requisitos son muy claros y están correctamente especificados.<a href="https://es.wikipedia.org/wiki/Software#cite_note-modelos-10">10</a></p>
                  <p>Hay más variantes similares al modelo: refino de etapas (más etapas, menores y más específicas) o incluso mostrar menos etapas de las indicadas, aunque en tal caso la faltante estará dentro de alguna otra. El orden de esas fases indicadas en el ítem previo es el lógico y adecuado, pero adviértase, como se dijo, que normalmente habrá realimentación hacia atrás.</p>
                  <p>El modelo lineal o en cascada es el paradigma más antiguo y extensamente utilizado, sin embargo las críticas a él (ver desventajas) han puesto en duda su eficacia. Pese a todo, tiene un lugar muy importante en la <a href="https://es.wikipedia.org/wiki/Ingenier%C3%ADa_de_software" title="Ingeniería de software">Ingeniería de software</a> y continúa siendo el más utilizado; y siempre es mejor que un enfoque al azar.<a href="https://es.wikipedia.org/wiki/Software#cite_note-modelos-10">10</a></p>
                  <p>Desventajas del modelo cascada:<a href="https://es.wikipedia.org/wiki/Software#cite_note-Cvida-6">6</a></p>
                  <ul>
                    <li>Los cambios introducidos durante el desarrollo pueden confundir al equipo profesional en las etapas tempranas del proyecto. Si los cambios se producen en etapa madura (codificación o prueba) pueden ser catastróficos para un proyecto grande.</li>
                    <li>No es frecuente que el cliente o usuario final explicite clara y completamente los requisitos (etapa de inicio); y el modelo lineal lo requiere. La incertidumbre natural en los comienzos es luego difícil de acomodar.<a href="https://es.wikipedia.org/wiki/Software#cite_note-modelos-10">10</a></li>
                    <li>El cliente debe tener paciencia ya que el software no estará disponible hasta muy avanzado el proyecto. Un error detectado por el cliente (en fase de operación) puede ser desastroso, implicando reinicio del proyecto, con altos costos.</li>
                  </ul>
                  <h4><span id="Modelos_evolutivos">Modelos evolutivos</span></h4>
                  <p>El software evoluciona con el tiempo.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Evo1-11">11</a> <a href="https://es.wikipedia.org/wiki/Software#cite_note-Evo2-9">9</a> Los requisitos del usuario y del producto suelen cambiar conforme se desarrolla el mismo. Las fechas de mercado y la competencia hacen que no sea posible esperar a poner en el mercado un producto absolutamente completo, por lo que se aconsejable introducir una versión funcional limitada de alguna forma para aliviar las presiones competitivas.</p>
                  <p>En esas u otras situaciones similares los desarrolladores necesitan modelos de progreso que estén diseñados para acomodarse a una evolución temporal o progresiva, donde los requisitos centrales son conocidos de antemano, aunque no estén bien definidos a nivel detalle.</p>
                  <p>En el modelo cascada y cascada realimentado no se tiene demasiado en cuenta la naturaleza evolutiva del software,<a href="https://es.wikipedia.org/wiki/Software#cite_note-Evo1-11">11</a> se plantea como estático, con requisitos bien conocidos y definidos desde el inicio.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Cvida-6">6</a></p>
                  <p>Los evolutivos son modelos iterativos, permiten desarrollar versiones cada vez más completas y complejas, hasta llegar al objetivo final deseado; incluso evolucionar más allá, durante la fase de operación.</p>
                  <p>Los modelos «iterativo incremental» y «espiral» (entre otros) son dos de los más conocidos y utilizados del tipo evolutivo.<a href="https://es.wikipedia.org/wiki/Software#cite_note-modelos-10">10</a></p>
                  <h5><span id="Modelo_iterativo_incremental">Modelo iterativo incremental</span></h5>
                  <p>En términos generales, se puede distinguir, en la Figura 4, los pasos generales que sigue el proceso de desarrollo de un producto software. En el modelo de ciclo de vida seleccionado, se identifican claramente dichos pasos. La descripción del sistema es esencial para especificar y confeccionar los distintos incrementos hasta llegar al producto global y final. Las actividades concurrentes (especificación, desarrollo y validación) sintetizan el desarrollo pormenorizado de los incrementos, que se hará posteriormente.</p>
                  <p>El diagrama de la Figura 4 muestra en forma muy esquemática, el funcionamiento de un ciclo iterativo incremental, el cual permite la entrega de versiones parciales a medida que se va construyendo el producto final.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Cvida-6">6</a> Es decir, a medida que cada incremento definido llega a su etapa de operación y mantenimiento. Cada versión emitida incorpora a los anteriores incrementos las funcionalidades y requisitos que fueron analizados como necesarios.</p>
                  <p><em>El incremental es un modelo de tipo evolutivo que está basado en varios ciclos Cascada Realimentados aplicados repetidamente, con una filosofía iterativa.</em><a href="https://es.wikipedia.org/wiki/Software#cite_note-modelos-10">10</a> En la Figura 5 se muestra un refino del diagrama previo, bajo un esquema temporal, para obtener finalmente el esquema del modelo de ciclo de vida Iterativo Incremental, con sus actividades genéricas asociadas. Aquí se observa claramente cada ciclo cascada que es aplicado para la obtención de un incremento; estos últimos se van integrando para obtener el producto final completo. Cada incremento es un ciclo Cascada Realimentado, aunque, por simplicidad, en la Figura 5 se muestra como secuencial puro.</p>
                  <p>Se observa que existen actividades de desarrollo (para cada incremento) que son realizadas en paralelo o concurrentemente, así por ejemplo, en la Figura, mientras se realiza el diseño detalle del primer incremento ya se está realizando en análisis del segundo. La Figura 5 es sólo esquemática, un incremento no necesariamente se iniciará durante la fase de diseño del anterior, puede ser posterior (incluso antes), en cualquier tiempo de la etapa previa. Cada incremento concluye con la actividad de «operación y mantenimiento» (indicada como «Operación» en la figura), que es donde se produce la entrega del producto parcial al cliente. El momento de inicio de cada incremento es dependiente de varios factores: tipo de sistema; independencia o dependencia entre incrementos (dos de ellos totalmente independientes pueden ser fácilmente iniciados al mismo tiempo si se dispone de personal suficiente); capacidad y cantidad de profesionales involucrados en el desarrollo; etc.</p>
                  <p>Bajo este modelo se entrega software «por partes funcionales más pequeñas», pero reutilizables, llamadas incrementos. En general cada incremento se construye sobre aquel que ya fue entregado.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Cvida-6">6</a></p>
                  <p>Como se muestra en la Figura 5, se aplican secuencias Cascada en forma escalonada, mientras progresa el tiempo calendario. Cada secuencia lineal o Cascada produce un incremento y a menudo el primer incremento es un sistema básico, con muchas funciones suplementarias (conocidas o no) sin entregar.</p>
                  <p>El cliente utiliza inicialmente ese sistema básico, intertanto, el resultado de su uso y evaluación puede aportar al plan para el desarrollo del/los siguientes incrementos (o versiones). Además también aportan a ese plan otros factores, como lo es la priorización (mayor o menor urgencia en la necesidad de cada incremento en particular) y la dependencia entre incrementos (o independencia).</p>
                  <p>Luego de cada integración se entrega un producto con mayor funcionalidad que el previo. El proceso se repite hasta alcanzar el software final completo.</p>
                  <p>Siendo iterativo, <em>con el modelo incremental se entrega un producto parcial pero completamente operacional en cada incremento</em>, y no una parte que sea usada para reajustar los requisitos (como si ocurre en el <a href="https://es.wikipedia.org/wiki/Modelo_de_prototipos" title="Modelo de prototipos">modelo de construcción de prototipos</a>).<a href="https://es.wikipedia.org/wiki/Software#cite_note-modelos-10">10</a></p>
                  <p>El enfoque incremental resulta muy útil cuando se dispone de baja dotación de personal para el desarrollo; también si no hay disponible fecha límite del proyecto por lo que se entregan versiones incompletas pero que proporcionan al usuario funcionalidad básica (y cada vez mayor). También es un modelo útil a los fines de versiones de evaluación.</p>
                  <p>Nota: Puede ser considerado y útil, en cualquier momento o incremento incorporar temporalmente el paradigma <a href="https://es.wikipedia.org/wiki/Modelo_de_prototipos" title="Modelo de prototipos">MCP</a> como complemento, teniendo así una mixtura de modelos que mejoran el esquema y desarrollo general.</p>
                  <p>Ejemplo:</p>
                  <dl>
                    <dd>Un <a href="https://es.wikipedia.org/wiki/Procesador_de_texto" title="Procesador de texto">procesador de texto</a> que sea desarrollado bajo el paradigma Incremental podría aportar, en principio, funciones básicas de edición de archivos y producción de documentos (algo como un <a href="https://es.wikipedia.org/wiki/Editor_de_texto" title="Editor de texto">editor simple</a>). En un segundo incremento se le podría agregar edición más sofisticada, y de generación y mezcla de <a href="https://es.wikipedia.org/wiki/Documento_electr%C3%B3nico" title="Documento electrónico">documentos</a>. En un tercer incremento podría considerarse el agregado de funciones de <a href="https://es.wikipedia.org/wiki/Corrector_ortogr%C3%A1fico" title="Corrector ortográfico">corrección ortográfica</a>, esquemas de paginado y <a href="https://es.wikipedia.org/wiki/Plantilla" title="Plantilla">plantillas</a>; en un cuarto capacidades de dibujo propias y ecuaciones matemáticas. Así sucesivamente hasta llegar al procesador final requerido. Así, el producto va creciendo, acercándose a su meta final, pero desde la entrega del primer incremento ya es útil y funcional para el cliente, el cual observa una respuesta rápida en cuanto a entrega temprana; sin notar que la fecha límite del proyecto puede no estar acotada ni tan definida, lo que da margen de operación y alivia presiones al equipo de desarrollo.</dd>
                  </dl>
                  <p>Como se dijo, el Iterativo Incremental es un modelo del tipo evolutivo, es decir donde se permiten y esperan probables cambios en los requisitos en tiempo de desarrollo; se admite cierto margen para que el software pueda evolucionar.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Evo2-9">9</a> Aplicable cuando los requisitos son medianamente bien conocidos pero no son completamente estáticos y definidos, cuestión esa que si es indispensable para poder utilizar un modelo Cascada.</p>
                  <p>El modelo es aconsejable para el desarrollo de software en el cual se observe, en su etapa inicial de análisis, que posee áreas bastante bien definidas a cubrir, con suficiente independencia como para ser desarrolladas en etapas sucesivas. Tales áreas a cubrir suelen tener distintos grados de apremio por lo cual las mismas se deben priorizar en un análisis previo, es decir, definir cual será la primera, la segunda, y así sucesivamente; esto se conoce como «definición de los incrementos» con base en la priorización. Pueden no existir prioridades funcionales por parte del cliente, pero el desarrollador debe fijarlas de todos modos y con algún criterio, ya que basándose en ellas se desarrollarán y entregarán los distintos incrementos.</p>
                  <p>El hecho de que existan incrementos funcionales del software lleva inmediatamente a pensar en un esquema de desarrollo <a href="https://es.wikipedia.org/wiki/Programaci%C3%B3n_modular" title="Programación modular">modular</a>, por tanto este modelo facilita tal paradigma de diseño.</p>
                  <p>En resumen, un modelo incremental lleva a pensar en un desarrollo modular, con entregas parciales del producto software denominados «incrementos» del sistema, que son escogidos según prioridades predefinidas de algún modo. El modelo permite una implementación con refinamientos sucesivos (ampliación o mejora). Con cada incremento se agrega nueva funcionalidad o se cubren nuevos requisitos o bien se mejora la versión previamente implementada del producto software.</p>
                  <p>Este modelo brinda cierta flexibilidad para que durante el desarrollo se incluyan cambios en los requisitos por parte del usuario, un cambio de requisitos propuesto y aprobado puede analizarse e implementarse como un nuevo incremento o, eventualmente, podrá constituir una mejora/adecuación de uno ya planeado. Aunque si se produce un cambio de requisitos por parte del cliente que afecte incrementos previos ya terminados (detección/incorporación tardía) <em>se debe evaluar la factibilidad y realizar un acuerdo con el cliente, ya que puede impactar fuertemente en los costos.</em></p>
                  <p>La selección de este modelo permite realizar <strong>entregas funcionales tempranas al cliente</strong> (lo cual es beneficioso tanto para él como para el grupo de desarrollo). Se priorizan las entregas de aquellos módulos o incrementos en que surja la necesidad operativa de hacerlo, por ejemplo para cargas previas de información, indispensable para los incrementos siguientes.<a href="https://es.wikipedia.org/wiki/Software#cite_note-modelos-10">10</a></p>
                  <p>El modelo iterativo incremental no obliga a especificar con precisión y detalle absolutamente todo lo que el sistema debe hacer, (y cómo), antes de ser construido (como el caso del cascada, con requisitos congelados). Sólo se hace en el incremento en desarrollo. Esto torna más manejable el proceso y reduce el impacto en los costos. Esto es así, porque en caso de alterar o rehacer los requisitos, solo afecta una parte del sistema. Aunque, lógicamente, esta situación se agrava si se presenta en estado avanzado, es decir en los últimos incrementos. <em>En definitiva, el modelo facilita la incorporación de nuevos requisitos durante el desarrollo.</em></p>
                  <p>Con un paradigma incremental se reduce el tiempo de desarrollo inicial, ya que se implementa funcionalidad parcial. También provee un impacto ventajoso frente al cliente, que es la entrega temprana de partes operativas del software.</p>
                  <p>El modelo proporciona todas las ventajas del modelo en cascada realimentado, reduciendo sus desventajas sólo al ámbito de cada incremento.</p>
                  <p>El modelo incremental no es recomendable para casos de sistemas de <a href="https://es.wikipedia.org/wiki/Tiempo_real" title="Tiempo real">tiempo real</a>, de alto nivel de seguridad, de <a href="https://es.wikipedia.org/wiki/Computaci%C3%B3n_distribuida" title="Computación distribuida">procesamiento distribuido</a>, o de alto índice de riesgos.</p>
                  <h5><span id="Modelo_espiral">Modelo espiral</span></h5>
                  <p>El modelo espiral fue propuesto inicialmente por <a href="https://es.wikipedia.org/wiki/Barry_Boehm" title="Barry Boehm">Barry Boehm</a>. Es un modelo evolutivo que conjuga la naturaleza iterativa del modelo <a href="https://es.wikipedia.org/wiki/Modelo_de_prototipos" title="Modelo de prototipos">MCP</a> con los aspectos controlados y sistemáticos del Modelo Cascada. Proporciona potencial para desarrollo rápido de versiones incrementales. En el modelo Espiral el software se construye en una serie de versiones incrementales. En las primeras iteraciones la versión incremental podría ser un modelo en papel o bien un prototipo. En las últimas iteraciones se producen versiones cada vez más completas del sistema diseñado.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Cvida-6">6</a> <a href="https://es.wikipedia.org/wiki/Software#cite_note-modelos-10">10</a></p>
                  <p>El modelo se divide en un número de Actividades de marco de trabajo, llamadas «<strong>regiones de tareas</strong>». En general existen entre tres y seis regiones de tareas (hay variantes del modelo). En la Figura 6 se muestra el esquema de un Modelo Espiral con 6 regiones. En este caso se explica una variante del modelo original de Boehm, expuesto en su tratado de 1988; en 1998 expuso un tratado más reciente.</p>
                  <p>Las regiones definidas en el modelo de la figura son:</p>
                  <ul>
                    <li>Región 1 - Tareas requeridas para establecer la comunicación entre el cliente y el desarrollador.</li>
                    <li>Región 2 - Tareas inherentes a la definición de los recursos, tiempo y otra información relacionada con el proyecto.</li>
                    <li>Región 3 - Tareas necesarias para evaluar los riesgos técnicos y de gestión del proyecto.</li>
                    <li>Región 4 - Tareas para construir una o más <em>representaciones</em> de la aplicación software.</li>
                    <li>Región 5 - Tareas para construir la aplicación, instalarla, probarla y proporcionar soporte al usuario o cliente (Ej. documentación y práctica).</li>
                    <li>Región 6 - Tareas para obtener la reacción del cliente, según la evaluación de lo creado e instalado en los ciclos anteriores.</li>
                  </ul>
                  <p>Las actividades enunciadas para el marco de trabajo son generales y se aplican a cualquier proyecto, grande, mediano o pequeño, complejo o no. Las regiones que definen esas actividades comprenden un «conjunto de tareas» del trabajo: ese conjunto sí se debe adaptar a las características del proyecto en particular a emprender. Nótese que lo listado en los ítems de 1 a 6 son conjuntos de tareas, algunas de las ellas normalmente dependen del proyecto o desarrollo en si.</p>
                  <p>Proyectos pequeños requieren baja cantidad de tareas y también de formalidad. En proyectos mayores o críticos cada región de tareas contiene labores de más alto nivel de formalidad. En cualquier caso se aplican actividades de protección (por ejemplo, gestión de configuración del software, garantía de calidad, etc.).</p>
                  <p>Al inicio del ciclo, o proceso evolutivo, el equipo de ingeniería gira alrededor del espiral (metafóricamente hablando) comenzando por el centro (marcado con ๑ en la Figura 6) y en el sentido indicado; el primer circuito de la espiral puede producir el desarrollo de una <a href="https://es.wikipedia.org/wiki/Especificaci%C3%B3n" title="Especificación">especificación</a> del producto; los pasos siguientes podrían generar un <a href="https://es.wikipedia.org/wiki/Prototipo" title="Prototipo">prototipo</a> y progresivamente versiones más sofisticadas del software.</p>
                  <p>Cada paso por la región de planificación provoca ajustes en el plan del proyecto; el coste y planificación se realimentan en función de la evaluación del cliente. El gestor de proyectos debe ajustar el número de iteraciones requeridas para completar el desarrollo.</p>
                  <p>El modelo espiral puede ir adaptándose y aplicarse a lo largo de todo el <a href="https://es.wikipedia.org/wiki/Ciclo_de_vida_del_software" title="Ciclo de vida del software">Ciclo de vida del software</a> (en el modelo clásico, o cascada, el proceso termina a la entrega del software).</p>
                  <p>Una visión alternativa del modelo puede observarse examinando el «eje de punto de entrada de proyectos». Cada uno de los circulitos (๏) fijados a lo largo del eje representan puntos de arranque de los distintos proyectos (relacionados); a saber:</p>
                  <ul>
                    <li>Un proyecto de «desarrollo de conceptos» comienza al inicio de la espiral, hace múltiples iteraciones hasta que se completa, es la zona marcada con verde.</li>
                    <li>Si lo anterior se va a desarrollar como producto real, se inicia otro proyecto: «Desarrollo de nuevo Producto». Que evolucionará con iteraciones hasta culminar; es la zona marcada en color azul.</li>
                    <li>Eventual y análogamente se generarán proyectos de «mejoras de productos» y de «mantenimiento de productos», con las iteraciones necesarias en cada área (zonas roja y gris, respectivamente).</li>
                  </ul>
                  <p>Cuando la espiral se caracteriza de esta forma, está operativa <strong>hasta que el software se retira</strong>, eventualmente puede estar inactiva (el proceso), pero cuando se produce un cambio el proceso arranca nuevamente en el punto de entrada apropiado (por ejemplo, en «mejora del producto»).</p>
                  <p>El modelo espiral da un enfoque realista, que evoluciona igual que el software;<a href="https://es.wikipedia.org/wiki/Software#cite_note-Evo1-11">11</a> se adapta muy bien para desarrollos a gran escala.</p>
                  <p>El Espiral utiliza el <a href="https://es.wikipedia.org/wiki/Modelo_de_prototipos" title="Modelo de prototipos">MCP</a> para reducir riesgos y permite aplicarlo en cualquier etapa de la evolución. Mantiene el enfoque clásico (cascada) pero incorpora un marco de trabajo iterativo que refleja mejor la realidad.</p>
                  <p>Este modelo <em>requiere considerar riesgos técnicos</em> en todas las etapas del proyecto; aplicado adecuadamente debe reducirlos antes de que sean un verdadero problema.</p>
                  <p>El Modelo evolutivo como el Espiral es particularmente apto para el desarrollo de Sistemas Operativos (complejos); también en sistemas de altos riesgos o críticos (Ej. navegadores y controladores aeronáuticos) y en todos aquellos en que sea necesaria una fuerte gestión del proyecto y sus riesgos, técnicos o de gestión.</p>
                  <p><strong>Desventajas importantes</strong>:</p>
                  <ul>
                    <li>Requiere mucha experiencia y habilidad para la evaluación de los riesgos, lo cual es requisito para el éxito del proyecto.</li>
                    <li>Es difícil convencer a los grandes clientes que se podrá controlar este enfoque evolutivo.</li>
                  </ul>
                  <p>Este modelo no se ha usado tanto, como el Cascada (Incremental) o <a href="https://es.wikipedia.org/wiki/Modelo_de_prototipos" title="Modelo de prototipos">MCP</a>, por lo que no se tiene bien medida su eficacia, es un paradigma relativamente nuevo y difícil de implementar y controlar.</p>
                  <h5><span id="Modelo_espiral_Win_.26_Win">Modelo espiral Win &amp; Win</span></h5>
                  <p>Una variante interesante del Modelo Espiral previamente visto (Figura 6) es el «Modelo espiral Win-Win»<a href="https://es.wikipedia.org/wiki/Software#cite_note-Pressman-Proceso-7">7</a> (<a href="https://es.wikipedia.org/wiki/Barry_Boehm" title="Barry Boehm">Barry Boehm</a>). El Modelo Espiral previo (clásico) sugiere la comunicación con el cliente para fijar los requisitos, en que simplemente se pregunta al cliente qué necesita y él proporciona la información para continuar; pero esto es en un contexto ideal que rara vez ocurre. Normalmente cliente y desarrollador entran en una negociación, se negocia coste frente a funcionalidad, rendimiento, calidad, etc.</p>
                  <p><em>«Es así que la obtención de requisitos requiere una negociación, que tiene éxito cuando ambas partes ganan».</em></p>
                  <p>Las mejores negociaciones se fuerzan en obtener «Victoria &amp; Victoria» (Win &amp; Win), es decir que el cliente gane obteniendo el producto que lo satisfaga, y el desarrollador también gane consiguiendo presupuesto y fecha de entrega realista. Evidentemente, este modelo requiere fuertes habilidades de negociación.</p>
                  <p>El modelo Win-Win define un conjunto de actividades de negociación al principio de cada paso alrededor de la espiral; se definen las siguientes actividades:</p>
                  <ol>
                    <li>Identificación del sistema o subsistemas clave de los directivos(*) (saber qué quieren).</li>
                    <li>Determinación de «condiciones de victoria» de los directivos (saber qué necesitan y los satisface)</li>
                    <li>Negociación de las condiciones «victoria» de los directivos para obtener condiciones «Victoria &amp; Victoria» (negociar para que ambos ganen).</li>
                  </ol>
                  <p>(*) Directivo: Cliente escogido con interés directo en el producto, que puede ser premiado por la organización si tiene éxito o criticado si no.</p>
                  <p>El modelo Win &amp; Win hace énfasis en la negociación inicial, también introduce 3 hitos en el proceso llamados «puntos de fijación», que ayudan a establecer la completitud de un ciclo de la espiral, y proporcionan hitos de decisión antes de continuar el proyecto de desarrollo del software.</p>
                  <h3><span id="Etapas_en_el_desarrollo_del_software">Etapas en el desarrollo del software</span></h3>
                  <h4><span id="Captura.2C_an.C3.A1lisis_y_especificaci.C3.B3n_de_requisitos">Captura, análisis y especificación de requisitos</span></h4>
                  <p>Al inicio de un desarrollo (no de un proyecto), esta es la primera fase que se realiza, y, según el modelo de proceso adoptado, puede casi terminar para pasar a la próxima etapa (caso de Modelo Cascada Realimentado) o puede hacerse parcialmente para luego retomarla (caso Modelo Iterativo Incremental u otros de carácter evolutivo).</p>
                  <p>En simple palabras y básicamente, durante esta fase, se adquieren, reúnen y especifican las características funcionales y no funcionales que deberá cumplir el futuro programa o sistema a desarrollar.</p>
                  <p>Las bondades de las características, tanto del sistema o programa a desarrollar, como de su entorno, parámetros no funcionales y arquitectura dependen enormemente de lo bien lograda que esté esta etapa. Esta es, probablemente, la de mayor importancia y una de las fases más difíciles de lograr certeramente, pues no es automatizable, no es muy técnica y depende en gran medida de la habilidad y experiencia del analista que la realice.</p>
                  <p>Involucra fuertemente al usuario o cliente del sistema, por tanto tiene matices muy subjetivos y es difícil de modelar con certeza o aplicar una técnica que sea «la más cercana a la adecuada» (de hecho no existe «la estrictamente adecuada»). Si bien se han ideado varias metodologías, incluso software de apoyo, para captura, elicitación y registro de requisitos, no existe una forma infalible o absolutamente confiable, y deben aplicarse conjuntamente buenos criterios y mucho sentido común por parte del o los analistas encargados de la tarea; es fundamental también lograr una fluida y adecuada comunicación y comprensión con el usuario final o cliente del sistema.</p>
                  <p>El <a href="https://es.wikipedia.org/wiki/Artefacto_(dise%C3%B1o_de_software)" title="Artefacto (diseño de software)">artefacto</a> más importante resultado de la culminación de esta etapa es lo que se conoce como <a href="https://es.wikipedia.org/wiki/Especificaci%C3%B3n_de_requisitos_de_software" title="Especificación de requisitos de software">especificación de requisitos software</a> o simplemente documento ERS.</p>
                  <p>Como se dijo, la habilidad del analista para interactuar con el cliente es fundamental; lo común es que el cliente tenga un objetivo general o problema que resolver, no conoce en absoluto el área (informática), ni su jerga, ni siquiera sabe con precisión qué debería hacer el producto software (qué y cuantas funciones) ni, mucho menos, cómo debe operar. En otros casos menos frecuentes, el cliente «piensa» que sabe precisamente lo que el software tiene que hacer, y generalmente acierta muy parcialmente, pero su empecinamiento entorpece la tarea de elicitación. El analista debe tener la capacidad para lidiar con este tipo de problemas, que incluyen relaciones humanas; tiene que saber ponerse al nivel del usuario para permitir una adecuada comunicación y comprensión.</p>
                  <p>Escasas son las situaciones en que el cliente sabe con certeza e incluso con completitud lo que requiere de su futuro sistema, este es el caso más sencillo para el analista.</p>
                  <p>Las tareas relativas a captura, elicitación, modelado y registro de requisitos, además de ser sumamente importante, puede llegar a ser dificultosa de lograr acertadamente y llevar bastante tiempo relativo al proceso total del desarrollo; al proceso y metodologías para llevar a cabo este conjunto de actividades normalmente se las asume parte propia de la <a href="https://es.wikipedia.org/wiki/Ingenier%C3%ADa_de_Software" title="Ingeniería de Software">Ingeniería de Software</a>, pero dada la antedicha complejidad, actualmente se habla de una <a href="https://es.wikipedia.org/wiki/Ingenier%C3%ADa_de_requisitos" title="Ingeniería de requisitos">Ingeniería de requisitos</a><a href="https://es.wikipedia.org/wiki/Software#cite_note-12">12</a> , aunque ella aún no existe formalmente.</p>
                  <p>Hay grupos de estudio e investigación, en todo el mundo, que están exclusivamente abocados a idear modelos, técnicas y procesos para intentar lograr la correcta captura, análisis y registro de requisitos. Estos grupos son los que normalmente hablan de la Ingeniería de requisitos; es decir se plantea ésta como un área o disciplina pero no como una carrera universitaria en si misma.</p>
                  <p>Algunos requisitos no necesitan la presencia del cliente, para ser capturados o analizados; en ciertos casos los puede proponer el mismo analista o, incluso, adoptar unilateralmente decisiones que considera adecuadas (tanto en requisitos funcionales como no funcionales). Por citar ejemplos probables: Algunos requisitos sobre la arquitectura del sistema, requisitos no funcionales tales como los relativos al rendimiento, nivel de soporte a errores operativos, plataformas de desarrollo, relaciones internas o ligas entre la información (entre registros o tablas de datos) a almacenar en caso de bases o bancos de datos, etc. Algunos funcionales tales como opciones secundarias o de soporte necesarias para una mejor o más sencilla operatividad; etc.</p>
                  <p>La obtención de especificaciones a partir del cliente (u otros actores intervinientes) es un proceso humano muy interactivo e iterativo; normalmente a medida que se captura la información, se la analiza y realimenta con el cliente, refinándola, puliéndola y corrigiendo si es necesario; cualquiera sea el método de <a href="https://es.wikipedia.org/wiki/Especificaci%C3%B3n_de_Requisitos_Software" title="Especificación de Requisitos Software">ERS</a> utilizado. EL analista siempre debe llegar a conocer la temática y el problema que resolver, dominarlo, hasta cierto punto, hasta el ámbito que el futuro sistema a desarrollar lo abarque. Por ello el analista debe tener alta capacidad para comprender problemas de muy diversas áreas o disciplinas de trabajo (que no son específicamente suyas); así por ejemplo, si el sistema a desarrollar será para gestionar información de una aseguradora y sus sucursales remotas, el analista se debe compenetrar en cómo ella trabaja y maneja su información, desde niveles muy bajos e incluso llegando hasta los gerenciales. Dada a gran diversidad de campos a cubrir, los analistas suelen ser asistidos por especialistas, es decir gente que conoce profundamente el área para la cual se desarrollará el software; evidentemente una única persona (el analista) no puede abarcar tan vasta cantidad de áreas del conocimiento. En empresas grandes de desarrollo de productos software, es común tener analistas especializados en ciertas áreas de trabajo.</p>
                  <p>Contrariamente, no es problema del cliente, es decir él no tiene por qué saber nada de software, ni de diseños, ni otras cosas relacionadas; sólo se debe limitar a aportar objetivos, datos e información (de mano propia o de sus registros, equipos, empleados, etc) al analista, y guiado por él, para que, en primera instancia, defina el «<strong>Universo de Discurso</strong>», y con posterior trabajo logre confeccionar el adecuado documento <a href="https://es.wikipedia.org/wiki/Especificaci%C3%B3n_de_Requisitos_Software" title="Especificación de Requisitos Software">ERS</a>.</p>
                  <p>Es bien conocida la presión que sufren los desarrolladores de sistemas informáticos para comprender y rescatar las necesidades de los clientes/usuarios. Cuanto más complejo es el contexto del problema más difícil es lograrlo, a veces se fuerza a los desarrolladores a tener que convertirse en casi expertos de los dominios que analizan.</p>
                  <p>Cuando esto no sucede es muy probable que se genere un conjunto de requisitos<a href="https://es.wikipedia.org/wiki/Software#cite_note-13">13</a> erróneos o incompletos y por lo tanto un producto de software con alto grado de desaprobación por parte de los clientes/usuarios y un altísimo costo de reingeniería y mantenimiento. <em>Todo aquello que no se detecte, o resulte mal entendido en la etapa inicial provocará un fuerte impacto negativo en los requisitos, propagando esta corriente degradante a lo largo de todo el proceso de desarrollo e <strong>incrementando su perjuicio cuanto más tardía sea su detección</strong></em> (Bell y Thayer 1976)(Davis 1993).</p>
                  <h5><span id="Procesos.2C_modelado_y_formas_de_elicitaci.C3.B3n_de_requisitos">Procesos, modelado y formas de elicitación de requisitos</span></h5>
                  <p>Siendo que la captura, elicitación y especificación de requisitos, es una parte crucial en el proceso de desarrollo de software, ya que de esta etapa depende el logro de los objetivos finales previstos, se han ideado modelos y diversas metodologías de trabajo para estos fines. También existen herramientas software que apoyan las tareas relativas realizadas por el ingeniero en requisitos.</p>
                  <p>El estándar IEEE 830-1998 brinda una normalización de las «Prácticas Recomendadas para la Especificación de Requisitos Software».<a href="https://es.wikipedia.org/wiki/Software#cite_note-14">14</a></p>
                  <p>A medida que se obtienen los requisitos, normalmente se los va analizando, el resultado de este análisis, con o sin el cliente, se plasma en un documento, conocido como ERS o<a href="https://es.wikipedia.org/wiki/Especificaci%C3%B3n_de_Requisitos_Software" title="Especificación de Requisitos Software">Especificación de Requisitos Software</a>, cuya estructura puede venir definida por varios estándares, tales como <a href="https://es.wikipedia.org/wiki/CMMI" title="CMMI">CMMI</a>.</p>
                  <p>Un primer paso para realizar el relevamiento de información es el conocimiento y definición acertada lo que se conoce como «Universo de Discurso» del problema, que se define y entiende por:</p>
                  <p><strong>Universo de Discurso (UdeD)</strong>: es el contexto general en el cual el software deberá ser desarrollado y deberá operar. El UdeD incluye todas las fuentes de información y todas las personas relacionadas con el software. Esas personas son conocidas también como <strong>actores</strong> de ese universo. El UdeD es la realidad circunstanciada por el conjunto de objetivos definidos por quienes demandaron el software.</p>
                  <p>A partir de la extracción y análisis de información en su ámbito se obtienen todas las especificaciones necesarias y tipos de requisitos para el futuro producto software.</p>
                  <p>El objetivo de la <a href="https://es.wikipedia.org/wiki/Ingenier%C3%ADa_de_requisitos" title="Ingeniería de requisitos">Ingeniería de requisitos</a> (IR) es sistematizar el proceso de definición de requisitos permitiendo elicitar, modelar y analizar el problema, generando un compromiso entre los ingenieros de requisitos y los clientes/usuarios, ya que ambos participan en la generación y definición de los requisitos del sistema. La IR aporta un conjunto de métodos, técnicas y herramientas que asisten a los ingenieros de requisitos (analistas) para obtener requisitos lo más seguros, veraces, completos y oportunos posibles, permitiendo básicamente:</p>
                  <ul>
                    <li>Comprender el problema</li>
                    <li>Facilitar la obtención de las necesidades del cliente/usuario</li>
                    <li>Validar con el cliente/usuario</li>
                    <li>Garantizar las especificaciones de requisitos</li>
                  </ul>
                  <p>Si bien existen diversas formas, modelos y metodologías para elicitar, definir y documentar requisitos, no se puede decir que alguna de ellas sea mejor o peor que la otra, suelen tener muchísimo en común, y todas cumplen el mismo objetivo. Sin embargo, lo que si se puede decir sin dudas es que es indispensable utilizar alguna de ellas para documentar las especificaciones del futuro producto software. Así por ejemplo, hay un grupo de investigación argentino que desde hace varios años ha propuesto y estudia el uso del LEL (Léxico Extendido del Lenguaje) y Escenarios como metodología, aquí<a href="https://es.wikipedia.org/wiki/Software#cite_note-15">15</a> se presenta una de las tantas referencias y bibliografía sobre ello. Otra forma, más ortodoxa, de capturar y documentar requisitos se puede obtener en detalle, por ejemplo, en el trabajo de la Universidad de Sevilla sobre «Metodología para el Análisis de Requisitos de Sistemas Software».<a href="https://es.wikipedia.org/wiki/Software#cite_note-16">16</a></p>
                  <p>En la Figura 7 se muestra un esquema, más o menos riguroso, aunque no detallado, de los pasos y tareas a seguir para realizar la captura, análisis y especificación de requisitos software. También allí se observa qué artefacto o documento se obtiene en cada etapa del proceso. En el diagrama no se explicita metodología o modelo a utilizar, sencillamente se pautan las tareas que deben cumplirse, de alguna manera.</p>
                  <div>
                    <div><a href="https://commons.wikimedia.org/wiki/File:Proceso_Ing_Requisitos.jpg"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/Proceso_Ing_Requisitos.jpg/500px-Proceso_Ing_Requisitos.jpg" width="500" height="280" srcset="//upload.wikimedia.org/wikipedia/commons/b/bb/Proceso_Ing_Requisitos.jpg 1.5x" data-file-width="535" data-file-height="300"></a>
                      <div>
                        <div></div>
                        Figura 7: Diagrama de tareas para captura y análisis de requisitos.</div>
                    </div>
                  </div>
                  <p>Una posible lista, general y ordenada, de tareas recomendadas para obtener la definición de lo que se debe realizar, los productos a obtener y las técnicas a emplear durante la actividad de elicitación de requisitos, en fase de <a href="https://es.wikipedia.org/wiki/Especificaci%C3%B3n_de_Requisitos_Software" title="Especificación de Requisitos Software">Especificación de Requisitos Software</a> es:</p>
                  <ol>
                    <li>Obtener información sobre el dominio del problema y el sistema actual (UdeD).</li>
                    <li>Preparar y realizar las reuniones para elicitación/negociación.</li>
                    <li>Identificar/revisar los objetivos del usuario.</li>
                    <li>Identificar/revisar los objetivos del sistema.</li>
                    <li>Identificar/revisar los <a href="https://es.wikipedia.org/wiki/Requisito_(sistemas)" title="Requisito (sistemas)">requisitos</a> de información.</li>
                    <li>Identificar/revisar los <a href="https://es.wikipedia.org/wiki/Requisito_funcional" title="Requisito funcional">requisitos funcionales</a>.</li>
                    <li>Identificar/revisar los <a href="https://es.wikipedia.org/wiki/Requisito_no_funcional" title="Requisito no funcional">requisitos no funcionales</a>.</li>
                    <li>Priorizar objetivos y requisitos.</li>
                  </ol>
                  <p>Algunos principios básicos a tener en cuenta:</p>
                  <ul>
                    <li>Presentar y entender cabalmente el dominio de la información del problema.</li>
                    <li>Definir correctamente las funciones que debe realizar el Software.</li>
                    <li>Representar el comportamiento del software a consecuencias de acontecimientos externos, particulares, incluso inesperados.</li>
                    <li>Reconocer requisitos incompletos, ambiguos o contradictorios.</li>
                    <li>Dividir claramente los modelos que representan la información, las funciones y comportamiento y características no funcionales.</li>
                  </ul>
                  <h5><span id="Clasificaci.C3.B3n_e_identificaci.C3.B3n_de_requisitos">Clasificación e identificación de requisitos</span></h5>
                  <p>Se pueden identificar dos formas de requisitos:</p>
                  <ul>
                    <li>Requisitos de usuario: Los requisitos de usuario son frases en lenguaje natural junto a diagramas con los <strong>servicios que el sistema</strong> debe proporcionar, así como las restricciones bajo las que debe operar.</li>
                    <li>Requisitos de sistema: Los requisitos de sistema determinan los <strong>servicios del sistema</strong> y pero con las restricciones en detalle. Sirven como contrato.</li>
                  </ul>
                  <p>Es decir, ambos son lo mismo, pero con distinto nivel de detalle.</p>
                  <p>Ejemplo de requisito de usuario: El sistema debe hacer préstamos Ejemplo de requisito de sistema: Función préstamo: entrada código socio, código ejemplar; salida: fecha devolución; etc.</p>
                  <p>Se clasifican en tres los tipos de requisitos de sistema:</p>
                  <ul>
                    <li>Requisitos funcionales</li>
                  </ul>
                  <p>Los requisitos funcionales describen:</p>
                  <ul>
                    <li>Los servicios que proporciona el sistema (funciones).</li>
                    <li>La respuesta del sistema ante determinadas entradas.</li>
                    <li>El comportamiento del sistema en situaciones particulares.</li>
                  </ul>
                  <ul>
                    <li>Requisitos no funcionales</li>
                  </ul>
                  <p>Los requisitos no funcionales son restricciones de los servicios o funciones que ofrece el sistema (ej. cotas de tiempo, proceso de desarrollo, rendimiento, etc.)</p>
                  <dl>
                    <dd>
                      <dl>
                        <dd>Ejemplo 1. La biblioteca Central debe ser capaz de atender simultáneamente a todas las bibliotecas de la Universidad</dd>
                        <dd>Ejemplo 2. El tiempo de respuesta a una consulta remota no debe ser superior a 1/2 <a href="https://es.wikipedia.org/wiki/Segundo" title="Segundo">s</a></dd>
                      </dl>
                    </dd>
                  </dl>
                  <dl>
                    <dd>A su vez, hay tres tipos de requisitos no funcionales:</dd>
                  </dl>
                  <ul>
                    <li>Requisitos del producto. Especifican el comportamiento del producto (Ej. prestaciones, memoria, tasa de fallos, etc.)</li>
                    <li>Requisitos organizativos. Se derivan de las políticas y procedimientos de las organizaciones de los clientes y desarrolladores (Ej. estándares de proceso, lenguajes de programación, etc.)</li>
                    <li>Requisitos externos. Se derivan de factores externos al sistema y al proceso de desarrollo (Ej. requisitos legislativos, éticos, etc.)</li>
                  </ul>
                  <ul>
                    <li>Requisitos del dominio.</li>
                  </ul>
                  <p>Los requisitos del dominio se derivan del dominio de la aplicación y reflejan características de dicho dominio.</p>
                  <p>Pueden ser funcionales o no funcionales.</p>
                  <p>Ej. El sistema de biblioteca de la Universidad debe ser capaz de exportar datos mediante el Lenguaje de Intercomunicación de Bibliotecas de España (LIBE). Ej. El sistema de biblioteca no podrá acceder a bibliotecas con material censurado.</p>
                  <h4><span id="Dise.C3.B1o_del_sistema">Diseño del sistema</span></h4>
                  <p>En <a href="https://es.wikipedia.org/wiki/Ingenier%C3%ADa_de_software" title="Ingeniería de software">ingeniería de software</a>, el diseño es una fase de <a href="https://es.wikipedia.org/wiki/Ciclo_de_vida_del_software" title="Ciclo de vida del software">ciclo de vida del software</a>. Se basa en la especificación de requisitos producido por el análisis de los requisitos (fase de análisis), el diseño define <em>cómo</em> estos requisitos se cumplirán, la estructura que debe darse al sistema de software para que se haga realidad.</p>
                  <p>El diseño sigue siendo una fase separada del la programación o codificación, esta última corresponde a la traducción en un determinado <a href="https://es.wikipedia.org/wiki/Lenguaje_de_programaci%C3%B3n" title="Lenguaje de programación">lenguaje de programación</a> de las premisas adoptadas en el diseño.</p>
                  <p>Las distinciones entre las actividades mencionadas hasta ahora no siempre son claras cómo se quisiera en las teorías clásicas de ingeniería de software. El diseño, en particular, puede describir el funcionamiento interno de un sistema en diferentes niveles de detalle, cada una de ellos se coloca en una posición intermedia entre el análisis y codificación.</p>
                  <p>Normalmente se entiende por "diseño de la arquitectura" al diseño de "muy alto nivel", que sólo define la estructura del sistema en términos de la módulos de software de que se compone y las relaciones macroscópicas entre ellos. A este nivel de diseño pertenecen fórmulas como <a href="https://es.wikipedia.org/wiki/Cliente-servidor" title="Cliente-servidor">cliente-servidor</a> o &ldquo;tres niveles&rdquo;, o, más generalmente, las decisiones sobre el uso de la arquitectura de hardware especial que se utilice, el sistema operativo, <a href="https://es.wikipedia.org/wiki/DBMS" title="DBMS">DBMS</a>, <a href="https://es.wikipedia.org/wiki/Protocolo_de_red" title="Protocolo de red">Protocolos de red</a>, etc.</p>
                  <p>Un nivel intermedio de detalle puede definir la descomposición del sistema en módulos, pero esta vez con una referencia más o menos explícita al modo de descomposición que ofrece el particular <a href="https://es.wikipedia.org/wiki/Lenguaje_de_programaci%C3%B3n" title="Lenguaje de programación">lenguaje de programación</a> con el que el desarrollo se va a implementar, por ejemplo, en un diseño realizado con la tecnología de <a href="https://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos" title="Programación orientada a objetos">objetos</a>, el proyecto podría describir al sistema en términos de <a href="https://es.wikipedia.org/wiki/Clase_(inform%C3%A1tica)" title="Clase (informática)">clases</a> y sus interrelaciones.</p>
                  <p>El diseño detallado, por último, es una descripción del sistema muy cercana a la codificación (por ejemplo, describir no sólo las clases en abstracto, sino también sus atributos y los métodos con sus tipos).</p>
                  <p>Debido a la naturaleza "intangible" del software, y dependiendo de las herramientas que se utilizan en el proceso, la frontera entre el diseño y la codificación también puede ser virtualmente imposible de identificar. Por ejemplo, algunas <a href="https://es.wikipedia.org/wiki/Herramienta_CASE" title="Herramienta CASE">herramientas CASE</a> son capaces de generar código a partir de diagramas UML, los que describen gráficamente la estructura de un sistema software.</p>
                  <h4><span id="Codificaci.C3.B3n_del_software">Codificación del software</span></h4>
                  <p>Durante esta etapa se realizan las tareas que comúnmente se conocen como <a href="https://es.wikipedia.org/wiki/Programaci%C3%B3n" title="Programación">programación</a>; que consiste, esencialmente, en llevar a código fuente, en el lenguaje de programación elegido, todo lo diseñado en la fase anterior. Esta tarea la realiza el <a href="https://es.wikipedia.org/wiki/Programador" title="Programador">programador</a>, siguiendo por completo los lineamientos impuestos en el diseño y en consideración siempre a los requisitos funcionales y no funcionales (ERS) especificados en la primera etapa.</p>
                  <p>Es común pensar que la etapa de programación o codificación (algunos la llaman implementación) es la que insume la mayor parte del trabajo de desarrollo del software; sin embargo, esto puede ser relativo (y generalmente aplicable a sistemas de pequeño porte) ya que las etapas previas son cruciales, críticas y pueden llevar bastante más tiempo. Se suele hacer estimaciones de un 30% del tiempo total insumido en la programación, pero esta cifra no es consistente ya que depende en gran medida de las características del sistema, su criticidad y el lenguaje de programación elegido.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Pressman-Proceso-7">7</a> En tanto menor es el nivel del lenguaje mayor será el tiempo de programación requerido, así por ejemplo se tardaría más tiempo en codificar un <a href="https://es.wikipedia.org/wiki/Algoritmo" title="Algoritmo">algoritmo</a> en <a href="https://es.wikipedia.org/wiki/Lenguaje_ensamblador" title="Lenguaje ensamblador">lenguaje ensamblador</a> que el mismo programado en <a href="https://es.wikipedia.org/wiki/Lenguaje_C" title="Lenguaje C">lenguaje C</a>.</p>
                  <p>Mientras se programa la aplicación, sistema, o software en general, se realizan también tareas de depuración, esto es la labor de ir liberando al código de los errores factibles de ser hallados en esta fase (de semántica, sintáctica y lógica). Hay una suerte de solapamiento con la fase siguiente, ya que para depurar la lógica es necesario realizar pruebas unitarias, normalmente con datos de prueba; claro es que no todos los errores serán encontrados sólo en la etapa de programación, habrá otros que se encontrarán durante las etapas subsiguientes. La aparición de algún error funcional (mala respuesta a los requisitos) eventualmente puede llevar a retornar a la fase de diseño antes de continuar la codificación.</p>
                  <p>Durante la fase de programación, el código puede adoptar varios estados, dependiendo de la forma de trabajo y del lenguaje elegido, a saber:</p>
                  <ul>
                    <li><a href="https://es.wikipedia.org/wiki/C%C3%B3digo_fuente" title="Código fuente">Código fuente</a>: es el escrito directamente por los <a href="https://es.wikipedia.org/wiki/Programador" title="Programador">programadores</a> en editores de texto, lo cual genera el <a href="https://es.wikipedia.org/wiki/Programa_inform%C3%A1tico" title="Programa informático">programa</a>. Contiene el conjunto de instrucciones codificadas en algún lenguaje de alto nivel. Puede estar distribuido en paquetes, procedimientos, <a href="https://es.wikipedia.org/wiki/Biblioteca_(programa)" title="Biblioteca (programa)">bibliotecas</a> fuente, etc.</li>
                  </ul>
                  <ul>
                    <li><a href="https://es.wikipedia.org/wiki/C%C3%B3digo_objeto" title="Código objeto">Código objeto</a>: es el código binario o intermedio resultante de procesar con un <a href="https://es.wikipedia.org/wiki/Compilador" title="Compilador">compilador</a> el código fuente. Consiste en una <strong>traducción completa</strong> y de una sola vez de éste último. El código objeto no es inteligible por el ser humano (normalmente es formato binario) pero tampoco es directamente ejecutable por la computadora. Se trata de una representación intermedia entre el código fuente y el código ejecutable, a los fines de un enlace final con las rutinas de <a href="https://es.wikipedia.org/wiki/Biblioteca_(programa)" title="Biblioteca (programa)">biblioteca</a> y entre procedimientos o bien para su uso con un pequeño intérprete intermedio [a modo de distintos ejemplos véase <a href="https://es.wikipedia.org/wiki/EUPHORIA_(lenguaje_de_programaci%C3%B3n)" title="EUPHORIA (lenguaje de programación)">EUPHORIA</a>, (intérprete intermedio), <a href="https://es.wikipedia.org/wiki/FORTRAN" title="FORTRAN">FORTRAN</a> (compilador puro) <em><a href="https://es.wikipedia.org/wiki/MSIL" title="MSIL">MSIL (Microsoft Intermediate Language)</a></em> (intérprete) y <a href="https://es.wikipedia.org/wiki/BASIC" title="BASIC">BASIC</a> (intérprete puro, intérprete intermedio, compilador intermedio o compilador puro, depende de la versión utilizada)].
                      <ul>
                        <li>El código objeto <strong>no existe</strong> si el programador trabaja con un lenguaje <strong>a modo de intérprete puro</strong>, en este caso el mismo intérprete se encarga de traducir y ejecutar línea por línea el código fuente (de acuerdo al flujo del programa), en tiempo de ejecución. En este caso <strong>tampoco existe</strong> el o los archivos de <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_ejecutable" title="Código ejecutable">código ejecutable</a>. Una desventaja de esta modalidad es que la ejecución del programa o sistema es un poco más lenta que si se hiciera con un intérprete intermedio, y bastante más lenta que si existe el o los archivos de código ejecutable. Es decir no favorece el rendimiento en velocidad de ejecución. Pero una gran ventaja de la modalidad intérprete puro, es que él está forma de trabajo facilita enormemente la tarea de depuración del código fuente (frente a la alternativa de hacerlo con un compilador puro). Frecuentemente se suele usar una forma mixta de trabajo (si el lenguaje de programación elegido lo permite), es decir inicialmente trabajar a modo de intérprete puro, y una vez depurado el código fuente (liberado de errores) se utiliza un compilador del mismo lenguaje para obtener el código ejecutable completo, con lo cual se agiliza la depuración y la velocidad de ejecución se optimiza.</li>
                      </ul>
                    </li>
                  </ul>
                  <ul>
                    <li><a href="https://es.wikipedia.org/wiki/C%C3%B3digo_ejecutable" title="Código ejecutable">Código ejecutable</a>: Es el código binario resultado de <a href="https://es.wikipedia.org/wiki/Enlazador" title="Enlazador">enlazar</a> uno o más fragmentos de código objeto con las rutinas y <a href="https://es.wikipedia.org/wiki/Biblioteca_(programa)" title="Biblioteca (programa)">bibliotecas</a> necesarias. Constituye uno o más <a href="https://es.wikipedia.org/wiki/Archivo_binario" title="Archivo binario">archivos binarios</a> con un formato tal que el <a href="https://es.wikipedia.org/wiki/Sistema_operativo" title="Sistema operativo">sistema operativo</a> es capaz de cargarlo en la memoria <a href="https://es.wikipedia.org/wiki/Memoria_RAM" title="Memoria RAM">RAM</a> (eventualmente también parte en una <a href="https://es.wikipedia.org/wiki/Memoria_virtual" title="Memoria virtual">memoria virtual</a>), y proceder a su ejecución directa. Por lo anterior se dice que el código ejecutable es directamente «inteligible por la computadora». El código ejecutable, también conocido como <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_m%C3%A1quina" title="Código máquina">código máquina</a>, no existe si se programa con modalidad de «intérprete puro».</li>
                  </ul>
                  <h4><span id="Pruebas_.28unitarias_y_de_integraci.C3.B3n.29">Pruebas (unitarias y de integración)</span></h4>
                  <p>Entre las diversas <a href="https://es.wikipedia.org/wiki/Pruebas_de_software" title="Pruebas de software">pruebas</a> que se le efectúan al software se pueden distinguir principalmente:</p>
                  <ul>
                    <li><a href="https://es.wikipedia.org/wiki/Prueba_unitaria" title="Prueba unitaria">Prueba unitarias</a>: Consisten en probar o testear piezas de software pequeñas; a nivel de secciones, procedimientos, funciones y módulos; aquellas que tengan funcionalidades específicas. Dichas pruebas se utilizan para asegurar el correcto funcionamiento de secciones de código, mucho más reducidas que el conjunto, y que tienen funciones concretas con cierto grado de independencia.</li>
                    <li><a href="https://es.wikipedia.org/wiki/Pruebas_de_integraci%C3%B3n" title="Pruebas de integración">Pruebas de integración</a>: Se realizan una vez que las pruebas unitarias fueron concluidas <em>exitosamente</em>; con éstas se intenta asegurar que el sistema completo, incluso los subsistemas que componen las piezas individuales grandes del software funcionen correctamente al operar e inteoperar en conjunto.</li>
                  </ul>
                  <p>Las pruebas normalmente se efectúan con los llamados <a href="https://es.wikipedia.org/wiki/Caso_de_prueba" title="Caso de prueba">datos de prueba</a>, que es un conjunto seleccionado de datos típicos a los que puede verse sometido el sistema, los módulos o los bloques de código. También se escogen: Datos que llevan a condiciones límites al software a fin de probar su tolerancia y robustez; datos de utilidad para mediciones de rendimiento; datos que provocan condiciones eventuales o particulares poco comunes y a las que el software normalmente no estará sometido pero pueden ocurrir; etc. Los «datos de prueba» no necesariamente son ficticios o «creados», pero normalmente sí lo son los de poca probabilidad de ocurrencia.</p>
                  <p>Generalmente, existe un fase probatoria final y completa del software, llamada <a href="https://es.wikipedia.org/wiki/Beta_tester" title="Beta tester">Beta Test</a>, durante la cual el sistema instalado en condiciones normales de operación y trabajo es probado exhaustivamente a fin de encontrar errores, inestabilidades, respuestas erróneas, etc. que hayan pasado los previos controles. Estas son normalmente realizadas por personal idóneo contratado o afectado específicamente a ello. Los posibles errores encontrados se transmiten a los desarrolladores para su depuración. En el caso de software de desarrollo «a pedido», el usuario final (cliente) es el que realiza el Beta Test, teniendo para ello un período de prueba pactado con el desarrollador.</p>
                  <h4><span id="Instalaci.C3.B3n_y_paso_a_producci.C3.B3n">Instalación y paso a producción</span></h4>
                  <p>La <a href="https://es.wikipedia.org/wiki/Instalaci%C3%B3n_de_software" title="Instalación de software">instalación del software</a> es el proceso por el cual los programas desarrollados son transferidos apropiadamente al computador destino, inicializados, y, eventualmente,<a href="https://es.wikipedia.org/wiki/Configuraci%C3%B3n_(inform%C3%A1tica)" title="Configuración (informática)">configurados</a>; todo ello con el propósito de ser ya utilizados por el usuario final. Constituye la etapa final en el desarrollo propiamente dicho del software. Luego de ésta el producto entrará en la fase de funcionamiento y producción, para el que fuera diseñado.</p>
                  <p>La instalación, dependiendo del sistema desarrollado, puede consistir en una simple copia al <a href="https://es.wikipedia.org/wiki/Disco_duro" title="Disco duro">disco rígido</a> destino (casos raros actualmente); o bien, más comúnmente, con una de complejidad intermedia en la que los distintos archivos componentes del software (ejecutables, <a href="https://es.wikipedia.org/wiki/Biblioteca_(programa)" title="Biblioteca (programa)">bibliotecas</a>, datos propios, etc.) son <a href="https://es.wikipedia.org/wiki/Compresi%C3%B3n_de_datos" title="Compresión de datos">descomprimidos</a> y copiados a lugares específicos preestablecidos del disco; incluso se crean vínculos con otros productos, además del propio <a href="https://es.wikipedia.org/wiki/Sistema_operativo" title="Sistema operativo">sistema operativo</a>. Este último caso, comúnmente es un proceso bastante automático que es creado y guiado con heramientas software específicas (<a href="https://es.wikipedia.org/wiki/Sistema_de_gesti%C3%B3n_de_paquetes" title="Sistema de gestión de paquetes">empaquetado y distribución, instaladores</a>).</p>
                  <p>En productos de mayor complejidad, la segunda alternativa es la utilizada, pero es realizada o guiada por especialistas; puede incluso requerirse la instalación en varios y distintos computadores (instalación distribuida).</p>
                  <p>También, en software de mediana y alta complejidad normalmente es requerido un proceso de <a href="https://es.wikipedia.org/wiki/Configuraci%C3%B3n_(inform%C3%A1tica)" title="Configuración (informática)">configuración</a> y chequeo, por el cual se asignan adecuados parámetros de funcionamiento y se testea la operatividad funcional del producto.</p>
                  <p>En productos de venta masiva las instalaciones completas, si son relativamente simples, suelen ser realizadas por los propios usuarios finales (tales como sistemas operativos, paquetes de oficina, utilitarios, etc.) con herramientas propias de instalación guiada; incluso la configuración suele ser automática. En productos de diseño específico o «a medida» la instalación queda restringida, normalmente, a personas especialistas involucradas en el desarrollo del software en cuestión.</p>
                  <p>Una vez realizada exitosamente la instalación del software, el mismo pasa a la fase de producción (operatividad), durante la cual cumple las funciones para las que fue desarrollado, es decir, es finalmente utilizado por el (o los) usuario final, produciendo los resultados esperados.</p>
                  <h4><span id="Mantenimiento">Mantenimiento</span></h4>
                  <p>El <a href="https://es.wikipedia.org/wiki/Mantenimiento_de_software" title="Mantenimiento de software">mantenimiento de software</a> es el proceso de control, mejora y optimización del software ya desarrollado e instalado, que también incluye depuración de errores y defectos que puedan haberse filtrado de la fase de pruebas de control y beta test. Esta fase es la última (antes de iterar, según el modelo empleado) que se aplica al ciclo de vida del desarrollo de software. La fase de mantenimiento es la que viene después de que el software está operativo y en producción.</p>
                  <p>De un buen diseño y documentación del desarrollo dependerá cómo será la fase de mantenimiento, tanto en costo temporal como monetario. Modificaciones realizadas a un software que fue elaborado con una documentación indebida o pobre y mal diseño puede llegar a ser tanto o más costosa que desarrollar el software desde el inicio. Por ello, es de fundamental importancia respetar debidamente todas las tareas de las fases del desarrollo y mantener adecuada y completa la documentación.</p>
                  <p>El período de la fase de mantenimiento es normalmente el mayor en todo el ciclo de vida.<a href="https://es.wikipedia.org/wiki/Software#cite_note-Pressman-Proceso-7">7</a> Esta fase involucra también actualizaciones y evoluciones del software; no necesariamente implica que el sistema tuvo errores. Uno o más cambios en el software, por ejemplo de adaptación o evolutivos, puede llevar incluso a rever y adaptar desde parte de las primeras fases del desarrollo inicial, alterando todas las demás; dependiendo de cuán profundos sean los cambios. El modelo cascada común es particularmente costoso en mantenimiento, ya que su rigidez implica que cualquier cambio provoca regreso a fase inicial y fuertes alteraciones en las demás fases del ciclo de vida.</p>
                  <p>Durante el período de mantenimiento, es común que surjan nuevas revisiones y versiones del producto; que lo liberan más depurado, con mayor y mejor funcionalidad, mejor rendimiento, etc. Varias son las facetas que pueden ser alteradas para provocar cambios deseables, evolutivos, adaptaciones o ampliaciones y mejoras.</p>
                  <p>Básicamente se tienen los siguientes tipos de cambios:</p>
                  <ul>
                    <li>Perfectivos: Aquellos que llevan a una mejora de la calidad interna del software en cualquier aspecto: Reestructuración del código, definición más clara del sistema y su documentación; optimización del rendimiento y eficiencia.</li>
                    <li>Evolutivos: Agregados, modificaciones, incluso eliminaciones, necesarias en el software para cubrir su expansión o cambio, según las necesidades del usuario.</li>
                    <li>Adaptivos: Modificaciones que afectan a los entornos en los que el sistema opera, tales como: Cambios de configuración del hardware (por actualización o mejora de componentes electrónicos), cambios en el software de base, en gestores de base de datos, en comunicaciones, etc.</li>
                    <li>Correctivos: Alteraciones necesarias para corregir errores de cualquier tipo en el producto software desarrollado.</li>
                  </ul>
      </article>
    </section>
    <Footer> </Footer>
   </body>
    <script src="js/modernizr.js"></script>   
    <script src="js/prefixfree.min.js"></script>
    <script src="js/jquery-2.1.1.js"></script>   
</html>